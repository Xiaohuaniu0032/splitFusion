import sys
import argparse
import re
import os
import gzip
from collections import defaultdict

def parse_args():
    AP = argparse.ArgumentParser("extract fusion result from svscan's sv result file")
    AP.add_argument('-sv',help='sv file generated by svscan',dest='svFile')
    AP.add_argument('-bam',help='tumor bam file',dest='bam')
    AP.add_argument('-bed',help='bed file',dest='bed')
    AP.add_argument('-annot',help='gene annot file',dest='annot',default='/data1/workdir/wangce/software/svscan/svdb/dna/anndb/anno.sort.rmchr.gz')
    AP.add_argument('-fsDBDIR',help='COSMIC,OncoKB,and <paper published fusion> database',dest='fusionDB',default='/data1/workdir/wangce/software/svscan/svdb/fusion')
    AP.add_argument('-blist',help='blacklist for fusion gene',dest='blist',default='/data1/workdir/wangce/software/svscan/svdb/fusion/fusion.blacklist.txt')
    AP.add_argument('-samtools',help='samtools executable program',dest='samtools',default='/data1/workdir/wangce/software/samtools-1.8/samtools')
    AP.add_argument('-od',help='output dir',dest='outdir')

    return AP.parse_args()

'''
《--------------------------------------过滤规则(是否展示)--------------------------------------》
    1）过滤BED：至少一端基因必须在BED区间（at least one gene's breakpoint need to be covered by BED）
    2）如果一端的断点注释到基因间区，过滤掉（one side breakpoint can not annot with a gene）
    3）过滤非编码基因LINC***（non-coding gene)
    4）过滤黑名单基因（blacklist gene）
    5）过滤基因内融合（hgene and tgene are the same）
    6）DEL/DUP need to on the same strand
    7）INV/DEL/DUP need to on the same chrom
    8）INV/DEL/DUP SVsize need > 2000
    9）hgene->tgene need to be 5'->3'
    #10）常见融合：split read seed count need >= 2；不常见融合：split seed >= 9
    #11）常见融合：fusion support mol need >= 2；不常见融合：fusion support mol need >= 9
    12) total depth need >= 30X
    13) 过滤LOC***、HLA-*基因
    14）过滤简单串联重复（SSR）融合序列
    #15）不常见融合：融合位点两端深度需>=3 (BND depth failed)

《 --------------------------------------报出规则(是否为YES)------------------------------------》
在上述过滤的基础上：
    1.常见融合：split read seed count need >= 2 & fusion support mol need >=2 报出
    2.不常见融合：split seed >= 9 & fusion support mol need >= 9 & 融合位点两端深度需>=3 & fusion freq >= 1% 报出
'''

def parse_fsDB(fs_db_file):
    '''
    parse three files:
        1) COSMIC.fusion.txt <https://cancer.sanger.ac.uk/cosmic/fusion>
        2) OncoKB.fusion.txt <https://www.oncokb.org/actionableGenes>
        3) paper.fusion.txt

    file is in abs path
    the format for these three files is not the same
    '''

    fs_db_name = os.path.basename(fs_db_file).split('.')[0] # COSMIC/OncoKB/paper

    fs_gene_db = {}

    if fs_db_name == 'COSMIC':
        fs_file = open(fs_db_file,'r')
        for line in fs_file:
            fgene = line.split('\t')[0]
            g1 = fgene.split('-')[0]
            g2 = fgene.split('-')[1]

            '''
            1. EML4-ALK
                a. <https://cancer.sanger.ac.uk/cosmic/fusion/overview?fid=180308&gid=150139>
                b. 5' Partner Gene: EML4
                c. 3' Partner Gene: ALK
            2. ASPSCR1_ENST00000306739-TFE3
                a. <https://cancer.sanger.ac.uk/cosmic/fusion/overview?fid=38946&gid=187223>
                b. 5' Partner Gene: ASPSCR1 or TFE3
                c. 3' Partner Gene: ASPSCR1 or TFE3
            3. CDH11-USP6_ENST00000250066
                a.
                b.
                c.
            4. ARFIP1_ENST00000353617-FHDC1_ENST00000260008
                a. https://cancer.sanger.ac.uk/cosmic/fusion/overview?fid=42327&gid=45785
                b. 5' Partner Gene: ARFIP1
                c. 3' Partner Gene: FHDC1
            '''
            
            if '_' in g1:
                g1 = g1.split('_')[0] # remove '_ENSTxxxx'

            if '_' in g2:
                g2 = g2.split('_')[0]

            g1g2 = g1 + '-' + g2 # fusion gene: EML4-ALK

            fs_gene_db[g1g2] = 1 # key is a gene pair, ACBD6-RRP15
        fs_file.close()

    elif fs_db_name == 'OncoKB':
        '''
        OncoKB's gene fusion is 
        '''
        fs_file = open(fs_db_file,'r')
        for line in fs_file:
            line = line.strip()
            if line[0] == '#':
                continue
            if ',' in line:
                # st for 'BCR-ABL1' et
                continue
            else:
                fs_gene_db[line] = 1 # key is a single gene, any partner gene play with this gene may forms a clinical useful fusion transcript
        fs_file.close()
    else:
        # paper published fusion gene
        fs_file = open(fs_db_file,'r')
        for line in fs_file:
            line = line.strip()
            if line[0] == '#':
                continue
            else:
                fs_gene_db[line] = 1 # key is a gene pair, ACBD6-RRP15
        fs_file.close()

    return fs_gene_db



def main():
    args = parse_args()
    svfile = args.svFile
    name = os.path.basename(svfile).split('.')[0]
    fs = "%s/%s.svscan.fusion.xls" % (args.outdir,name)
    
    gene_NM_exon = defaultdict(dict)

    # read annot to get each NM's exon number
    with gzip.open(args.annot,'rt') as annotF:
        for line in annotF:
            arr = line.split('\t')
            if arr[4] == 'exon':
                gene = arr[-4]
                nm = arr[-5]
                if nm not in gene_NM_exon[gene]:
                    gene_NM_exon[gene][nm] = 1
                else:
                    gene_NM_exon[gene][nm] += 1


    of = open(fs,'w')
    header = ['#SampleID','FusionGene','Headgene','Tailgene','FusionReadsNumber','TotalReadsNumber','FusionRate(%)','COSMIC','OncoKB','IfReport','FilterReason','Gene1','Chr1','JunctionPosition1','Strand1','Transcript1','Region1','Gene2','Chr2','JunctionPosition2','Strand2','Transcript2','Region2','FusionSequence','SVType','svSize','insSeq','insLen','FusionOriPattern']
    of.write('\t'.join(header)+'\n')

    # READ BED FILE
    bed_gene = defaultdict(list)
    bed_fh = open(args.bed,'r')
    for line in bed_fh:
        arr = line.strip().split('\t')
        gene = line.strip().split('\t')[-1]
        target_region = arr[1] + '\t' + arr[2] # start-end
        bed_gene[gene].append(target_region)
    bed_fh.close()

    ### READ SV FILE
    infile = open(svfile,'r')
    next(infile) # skip header
    for line in infile:
        line.strip()
        val = line.split('\t')

        # check BED
        bp1Gene = val[-6]
        bp2Gene = val[-5]

        g1_list = []
        g2_list = []

        if ';' in bp1Gene:
            arr = bp1Gene.split(';')
            for line in arr:
                g = line.split(',')[0]
                if g not in g1_list:
                    g1_list.append(g)
        else:
            g = bp1Gene.split(',')[0]
            g1_list.append(g)

        if ';' in bp2Gene:
            arr = bp2Gene.split(';')
            for line in arr:
                g = line.split(',')[0]
                if g not in g2_list:
                    g2_list.append(g)
        else:
            g = bp2Gene.split(',')[0]
            g2_list.append(g)


        g1_pos = int(val[4])
        g2_pos = int(val[6])

        g1_flag = 0
        g2_flag = 0

        for g in g1_list:
            g1_pos_all = bed_gene[g]
            for POS in g1_pos_all:
                start_pos = int(POS.split('\t')[0])
                end_pos = int(POS.split('\t')[1])
                if g1_pos >= start_pos and g1_pos <= end_pos:
                    g1_flag += 1

        for g in g2_list:
            g2_pos_all = bed_gene[g]
            for POS in g2_pos_all:
                start_pos = int(POS.split('\t')[0])
                end_pos = int(POS.split('\t')[1])
                if g2_pos >= start_pos and g2_pos <= end_pos:
                    g2_flag += 1

        # at least one gene's breakpoint is covered by BED
        if g1_flag > 0 or g2_flag > 0:
            pass
        else:
            print("%s was filtered: [at least one gene's breakpoint need to be covered by BED" % val[-4])
            continue

        '''
        SV gene pair may contain multi pairs:
            1) NTRK1->LINC00486|NTRK1,5,-|LINC00486,5,+|5
        OR  2) TIMM23B->RET|TIMM23B,5,+|RET,3,+|2;NCOA4->RET|NCOA4,5,+|RET,3,+|2
        '''

        sv_info = val[-4]
        gene_pair = []

        if ';' in sv_info:
            # contail >= 2 sv pairs
            v = sv_info.split(';')
            for i in v:
                gene_pair.append(i)
        else:
            gene_pair.append(sv_info)

        for i in gene_pair:
            ###
            fusion_info = i # for backward comp
            fgene = i.split('|')[0] # EML4->ALK
            fgene1 = fgene.split('->')[0]
            fgene2 = fgene.split('->')[1]
            fgene_new = fgene1 + '-' + fgene2
            
            if fgene[0] == '-' or fgene[-1] == '-':
                # skip region do not annot with genes
                print("%s was filtered: [one side breakpoint can not annot with a gene]" % val[-4])
                continue

            if 'LINC' in fgene:
                # skip non-coding gene
                print("%s was filtered: [non-coding gene]" % val[-4])
                continue

            # i's format is: TIMM23B->RET|TIMM23B,5,+|RET,3,+|2
            hgene_fs_mode = i.split('|')[1] # TIMM23B,5,+
            tgene_fs_mode = i.split('|')[2] # RET,3,+

            hgene = hgene_fs_mode.split(',')[0] # TIMM23B
            tgene = tgene_fs_mode.split(',')[0] # RET

            
            # 检查黑名单基因
            blist_fh = open(args.blist,'r')
            blist_gene = {}
            for line in blist_fh:
                gene = line.strip().split(',')[0]
                blist_gene[gene] = 1

            blist_fh.close()

            if hgene in blist_gene or tgene in blist_gene:
                print("%s was filtered: [blacklist gene]" % val[-4])
                continue

            # read gene annot info
            g1_annot = val[-6] # RET,NM_020975.4,intron,+,11,12
            g2_annot = val[-5] # TIMM23B,NM_001290117.1,intron,+,6,6;NCOA4,NM_001145260.1,intron,+,11,11

            gene_annot_info = {} # gene's strnd info
            gene_transcript_info = {} # gene's transcript info
            gene_breakpoint_info = {} # gene's breakpoint pos info

            g1 = []
            g2 = []

            if ';' in g1_annot:
                g1_val = g1_annot.split(';')
                for v in g1_val:
                    gene = v.split(',')[0]
                    strand = v.split(',')[3]
                    gene_annot_info[gene] = strand
                    gene_transcript_info[gene] = v.split(',')[1]
                    reg = v.split(',')[-4] # exon/intron
                    reg_pos = v.split(',')[-2]
                    gene_breakpoint_info[gene] = [reg,reg_pos]
            else:
                gene = g1_annot.split(',')[0]
                strand = g1_annot.split(',')[3]
                gene_annot_info[gene] = strand
                gene_transcript_info[gene] = g1_annot.split(',')[1]
                reg = g1_annot.split(',')[-4] # exon/intron
                reg_pos = g1_annot.split(',')[-2]
                gene_breakpoint_info[gene] = [reg,reg_pos]

            if ';' in g2_annot:
                g2_val = g2_annot.split(';')
                for v in g2_val:
                    gene = v.split(',')[0]
                    strand = v.split(',')[3]
                    gene_annot_info[gene] = strand
                    gene_transcript_info[gene] = v.split(',')[1]
                    reg = v.split(',')[-4] # exon/intron
                    reg_pos = v.split(',')[-2]
                    gene_breakpoint_info[gene] = [reg,reg_pos]
            else:
                gene = g2_annot.split(',')[0]
                strand = g2_annot.split(',')[3]
                gene_annot_info[gene] = strand
                gene_transcript_info[gene] = g2_annot.split(',')[1]
                reg = g2_annot.split(',')[-4] # exon/intron
                reg_pos = g2_annot.split(',')[-2]
                gene_breakpoint_info[gene] = [reg,reg_pos]
            
            
            if hgene == tgene:
                print("%s was filtered: [hgene and tgene are the same]" % val[-4])
                continue

        
            if val[0] == 'DEL' or val[0] == 'DUP':
                hgene_strand = gene_annot_info[hgene]
                tgene_strand = gene_annot_info[tgene]

                if hgene_strand != tgene_strand:
                    print("%s was filtered: [DEL/DUP need to on the same strand]" % val[-4])
                    continue
            
            if val[0] == 'INV' or val[0] == 'DEL' or val[0] == 'DUP':
                # filter by chrom
                if val[3] != val[5]:
                    print("%s was filtered: [INV/DEL/DUP need to on the same chrom]" % val[-4])
                    continue
                # filter sv size
                if int(val[1]) <= 2000:
                    print("%s was filtered: [INV/DEL/DUP SVsize need > 2000]" % val[-4])
                    continue


            # get fusion pattern
            sv_ori_info = {}
            if ';' in sv_info:
                v = sv_info.split(';')
                for i in v:
                    hg_info = i.split('|')[1] # TIMM23B,5,+
                    tg_info = i.split('|')[2] # RET,3,+
                    hg = hg_info.split(',')[0]
                    tg = tg_info.split(',')[0]
                    sv_ori_info[hg] = hg_info.split(',')[-2]
                    sv_ori_info[tg] = tg_info.split(',')[-2]
            else:
                hg_info = sv_info.split('|')[1] # FANCD2,5,+
                tg_info = sv_info.split('|')[2]
                hg = hg_info.split(',')[0] # gene name
                tg = tg_info.split(',')[0]
                sv_ori_info[hg] = hg_info.split(',')[-2]
                sv_ori_info[tg] = tg_info.split(',')[-2]

            hgene_fs_ori = sv_ori_info[hgene] # 5' part or 3' part play with SV
            tgene_fs_ori = sv_ori_info[tgene]

            
            if hgene_fs_ori == '5' and tgene_fs_ori == '3':
                pass
            else:
                print("%s was filtered: [hgene->tgene need to be 5'->3']" % val[-4])
                continue


            # 计算融合分子支持数
            if hgene == 'NTRK1' or tgene == 'NTRK1':
                if int(val[11]) == 0 and int(val[7]) != 0:
                    # rate = （molRescued/(max(srRefCount, dpRefCount)+ molRescued)
                    # molRescued == 0 but srCount != 0
                    fnum = int(val[7])
                else:
                    fnum = int(val[11])
            else:
                fnum = int(val[11])
            

            # 计算总深度
            if hgene == 'NTRK1' or tgene == 'NTRK1':
                # svscan的检测结果中,NTRK1基因总深度为0,重新计算
                bnd_left_depth = cal_fusion_ref_depth(args.samtools,val[3],int(val[4]),args.bam,args.outdir) # 分子数
                bnd_right_depth = cal_fusion_ref_depth(args.samtools,val[5],int(val[6]),args.bam,args.outdir)
                tnum = max(bnd_left_depth,bnd_right_depth) # 取两端最大深度
            else:
                tnum = max(int(val[12]),int(val[13])) + int(val[11])

            
            # 过滤总深度太低的融合
            if tnum < 30:
                print("%s was filtered: [total depth need >= 30X]" % val[-4])
                continue
            
            # 计算融合频率
            # 格式:32.32(%)
            if hgene == 'NTRK1' or tgene == 'NTRK1':
                # re-calculate fusion freq
                ffreq = round(float(fnum/tnum) * 100, 4)
            else:
                ffreq = round(float(val[14]) * 100, 4)


            # COSMIC/OncoKB DB
            cosmic_fgene_file = args.fusionDB + '/COSMIC.fusion.txt'
            oncokb_fgene_file = args.fusionDB + '/OncoKB.fusion.txt'
            paper_fgene_file = args.fusionDB + '/paper.fusion.txt'

            # 检查COSMIC
            cosmic_dict = parse_fsDB(cosmic_fgene_file)

            fg1 = hgene + '-' + tgene
            fg2 = tgene + '-' + hgene

            if fg1 in cosmic_dict or fg2 in cosmic_dict:
                in_cosmic = 'Y'
            else:
                in_cosmic = '.'

            # 检查OncoKB
            oncokb_dict = parse_fsDB(oncokb_fgene_file)
            if hgene in oncokb_dict or tgene in oncokb_dict:
                in_onckb = 'Y'
            elif ((hgene == 'BCR' and tgene == 'ABL1') or (hgene =='ABL1' and tgene == 'BCR')):
                in_onckb = 'Y'
            elif ((hgene == 'PDGFB' and tgene == 'COL1A1') or (hgene == 'COL1A1' and tgene == 'PDGFB')):
                in_onckb = 'Y'
            elif ((hgene == 'PCM1' and tgene == 'JAK2') or (hgene == 'JAK2' and tgene == 'PCM1')):
                in_onckb = 'Y'
            else:
                in_onckb = '.'

            # gene chr/pos info
            gene_info = {} # chr/breakpoint
            gene1_info = val[-6] #### gene1 may not the hgene (g->g)
            g1 = []
            if ';' in gene1_info:
                v = gene1_info.split(';')
                for i in v:
                    g = i.split(',')[0]
                    g1.append(g)
            else:
                g = gene1_info.split(',')[0]
                g1.append(g)

            for g in g1:
                g1_chr = val[3]
                g1_pos = val[4]
                gene_info[g] = [g1_chr,g1_pos]

            gene2_info = val[-5]
            g2 = []
            if ';' in gene2_info:
                v = gene2_info.split(';')
                for i in v:
                    g = i.split(',')[0]
                    g2.append(g)
            else:
                g = gene2_info.split(',')[0]
                g2.append(g)

            for g in g2:
                g2_chr = val[5]
                g2_pos = val[6]
                gene_info[g] = [g2_chr,g2_pos]


            # for hgene info
            gene1 = hgene
            gene1_strand = gene_annot_info[gene1]
            gene1_trans = gene_transcript_info[gene1]
            gene1_chr = gene_info[gene1][0]
            gene1_pos = gene_info[gene1][1]

            if '.' in gene1_trans:
                gene1_trans = gene_transcript_info[gene1].split('.')[0] # NM_004304.4 => NM_004304


            # transcript's exon number
            if gene1 in gene_NM_exon and gene1_trans in gene_NM_exon[gene1]:
                gene1_exon_num = gene_NM_exon[gene1][gene1_trans]
            else:
                gene1_exon_num = 'NA'

            gene1_bnd_reg = gene_breakpoint_info[gene1][0] # exon/intron
            if gene1_bnd_reg == 'intron':
                # exon;19/29
                reg = gene_breakpoint_info[gene1][1]
                gene1_exon_info = 'intron' + ';' + reg + '/' + str(gene1_exon_num)
            else:
                reg = gene_breakpoint_info[gene1][1]
                gene1_exon_info = 'exon' + ';' + reg + '/' + str(gene1_exon_num)


            # for tgene info
            gene2 = tgene
            gene2_strand = gene_annot_info[gene2]
            gene2_trans = gene_transcript_info[gene2]
            gene2_chr = gene_info[gene2][0]
            gene2_pos = gene_info[gene2][1]

            if '.' in gene2_trans:
                gene2_trans = gene_transcript_info[gene2].split('.')[0]

            # transcript's exon number
            if gene2 in gene_NM_exon and gene2_trans in gene_NM_exon[gene2]:
                gene2_exon_num = gene_NM_exon[gene2][gene2_trans]
            else:
                gene2_exon_num = 'NA'

            gene2_bnd_reg = gene_breakpoint_info[gene2][0]
            if gene2_bnd_reg == 'intron':
                reg = gene_breakpoint_info[gene2][1]
                gene2_exon_info = 'intron' + ';' + reg + '/' + str(gene2_exon_num)
            else:
                reg = gene_breakpoint_info[gene2][1]
                gene2_exon_info = 'exon' + ';' + reg + '/' + str(gene2_exon_num)

            fseq = val[-10]
            svtype = val[0]
            svsize = val[1] # for inner chrom, this means how far two gene locate
            ins_seq = val[-11]
            ins_len = val[-12]

            fp_arr = fusion_info.split('|')
            fp = fp_arr[1] + ';' + fp_arr[2] # EML4,5,+;ALK,3,+
            

            # 过滤LOC***基因
            if 'LOC' in hgene:
                if hgene[:3] == 'LOC':#LOC开头
                    print("%s was filtered: [LOC***]" % val[-4])
                    continue

            if 'LOC' in tgene:
                if tgene[:3] == 'LOC':
                    print("%s was filtered: [LOC***]" % val[-4])
                    continue
            
            # 过滤HLA基因
            if 'HLA' in hgene:
                if hgene[:3] == 'HLA':
                    print("%s was filtered: [HLA-*]" % val[-4])
                    continue

            if 'HLA' in tgene:
                if tgene[:3] == 'HLA':
                    print("%s was filtered: [HLA-*]" % val[-4])
                    continue


            # 如果存在保守融合序列,检查断点两端的融合序列,有一边为简单重复序列,则过滤掉
            if val[20] != '-':
                bkp = int(val[21])
                fseq1 = val[20][:bkp]
                fseq2 = val[20][bkp:]

                fseq1_ssr = simple_seq_repeat_check(fseq1)
                fseq2_ssr = simple_seq_repeat_check(fseq2)

                if fseq1_ssr == 'SSR' or fseq2_ssr == 'SSR':
                    print("%s was filtered: [SSR]" % val[-4])
                    continue

            #《 --------------------------------------报出规则 --------------------------------------》
            # 在上述过滤的基础上：
                # 1.常见融合：split read seed count need >= 2 & fusion support mol need >=2 报出
                # 2.不常见融合：split seed >= 9 & fusion support mol need >= 9 & 融合位点两端深度需>=3 & fusion freq >= 1% 报出

            filter_reason = []

            if in_cosmic == 'Y':
                # 常见融合
                # split seed >= 2 & fusion mol >= 2
                if int(val[7]) >= 2 and fnum >= 2:
                    if_report = 'YES'
                    filter_reason.append('PASS')
                else:
                    if_report = 'NO'
                    filter_reason.append('split seed need >=2 && fusion mol need >=2')
            else:
                # 非常见融合
                # [seed >8 OR （seed > 6 and rescued > 10)] & fusion mol >= 9 & 断点两端深度 >= 3

                # 检查断点深度,有一端为0则过滤掉
                bnd_left_depth = check_bnd_depth(args.samtools,val[3],int(val[4]),args.bam,args.outdir)
                bnd_right_depth = check_bnd_depth(args.samtools,val[5],int(val[6]),args.bam,args.outdir)

                bnd_left_check = ''
                bnd_right_check = ''

                for v in bnd_left_depth:
                    if v >= 3:
                        bnd_left_check = 'OK'
            
                for v in bnd_right_depth:
                    if v >= 3:
                        bnd_right_check = 'OK'
                

                # check seed count
                seed_count_check = ''

                if int(val[7]) > 8:
                    seed_count_check = 'OK'
                else:
                    if int(val[7]) > 6 and int(val[9]) > 10:
                        seed_count_check = 'OK'
                
                if seed_count_check == 'OK' and fnum >= 9 and bnd_left_check == 'OK' and bnd_right_check == 'OK' and ffreq >= 1:
                    if_report = 'YES'
                    filter_reason.append('PASS')
                else:
                    if_report = 'NO'

                    if seed_count_check != 'OK':
                        filter_reason.append('seed count check Failed')

                    if fnum < 9:
                        filter_reason.append('fusion mol need >= 9')

                    if bnd_left_check != 'OK' or bnd_right_check != 'OK':
                        filter_reason.append('the depth at left and right BND need >= 3')

            filter_reason_str = ';'.join(filter_reason)


            g1_val = gene1 + '\t' + gene1_chr + '\t' + str(gene1_pos) + '\t' + gene1_strand + '\t' + gene1_trans + '\t' + gene1_exon_info # hgene
            g2_val = gene2 + '\t' + gene2_chr + '\t' + str(gene2_pos) + '\t' + gene2_strand + '\t' + gene2_trans + '\t' + gene2_exon_info # tgene

            val_line = name + '\t' + fgene_new + '\t' + hgene + '\t' + tgene + '\t' + str(fnum) + '\t' + str(tnum) + '\t' + str(ffreq) + '\t' + in_cosmic + '\t' + in_onckb + '\t' + if_report + '\t' + filter_reason_str + '\t' + g1_val + '\t' + g2_val + '\t' + fseq + '\t' + svtype + '\t' + str(svsize) + '\t' + ins_seq + '\t' + str(ins_len) + '\t' + fp

            of.write(val_line+'\n')
            
    of.close()



def simple_seq_repeat_check(seq):
    res = ''
    upper_seq = seq.upper()
    seqA = upper_seq.count('A')
    seqT = upper_seq.count('T')
    seqC = upper_seq.count('C')
    seqG = upper_seq.count('G')

    all_base = len(seq)
    # rule1:单碱基的频率需小于60%
    if seqA/all_base > 0.8 or seqT/all_base > 0.8 or seqC/all_base > 0.8 or seqG/all_base > 0.8:
        res = 'SSR'
    else:
        res = '-'

    # rule2:for 2bp motif, if 2bp motif's len > 0.8 * all_len
    base_set = ['A','T','C','G']
    twoBpMotif = []
    for b1 in base_set:
        for b2 in base_set:
            newBase = b1 + b2
            twoBpMotif.append(newBase)

    for mtf in twoBpMotif:
        rep_num = upper_seq.count(mtf)
        rep_pct = rep_num * 2 / all_base
        if rep_pct > 0.8:
            res = 'SSR'

    return res

def check_bnd_depth(samtools,chrom,pos,bam,outdir):
    # 检查断点及断点两侧各1bp位置的深度
    r = "%s:%s-%s" % (chrom,pos-5,pos+5)
    cmd = "%s depth -a -r %s %s >%s/bnd.depth.tmp" % (samtools,r,bam,outdir)
    os.system(cmd)

    # 检查深度文件：如果有任何一个位置深度不为0，且深度大于等于3，则该侧断点可信
    depth_f = "%s/bnd.depth.tmp" % (outdir)
    depth_fh = open(depth_f,'r')
     
    depth_info = []

    for line in depth_fh:
        depth = int(line.strip().split('\t')[-1])
        depth_info.append(depth)

    #print(depth_info)
    # rm tmp file
    if os.path.exists(depth_f):
        os.remove(depth_f)

    return depth_info


def cal_fusion_ref_depth(samtools,chrom,pos,bam,outdir):
    # used for cal NTRK1's depth
    r = "%s:%s-%s" % (chrom,pos-10,pos+10)
    cmd = "%s view %s %s | awk '{print $1}' | sort | uniq -c | wc -l >%s/samtools_depth.tmp" % (samtools,bam,r,outdir)
    os.system(cmd)
    
    # cal mean depth
    line_file = "%s/samtools_depth.tmp" % (outdir)
    depth_fh = open(line_file,'r')
    depth_sum = 0
    pos_n = 0
    for line in depth_fh:
        depth = int(line.strip().split('\t')[-1])
        depth_sum += depth
        pos_n += 1
    
    mean_depth = int(depth_sum/pos_n)

    if os.path.exists(line_file):
        os.remove(line_file)

    return(mean_depth)


if __name__ == "__main__":
    main()

